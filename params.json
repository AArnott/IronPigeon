{"body":"IronPigeon\r\n==========\r\n\r\n*IronPigeon is a decentralized communication protocol that provides high\r\nconfidentiality and authenticity for the messages.*\r\n\r\nMessages are signed for authenticity, encrypted for confidentiality,\r\nand transmitted indirectly so that eavesdroppers find it difficult or\r\nimpossible to establish *whether* two parties have even communicated,\r\n*what* was communicated or *how much* was communicated.\r\n\r\nThis project includes libraries that implement the protocol and a message\r\nrelay web service project that provides the cloud component necessary for\r\npassing messages.\r\n\r\nInstalling IronPigeon\r\n---------------------\r\n\r\nThe recommended way to acquire the binary is via the\r\n[IronPigeon][1] NuGet package.\r\n\r\nFor email-like message exchange, the [IronPigeon.Dart][2]\r\nNuGet package is recommended.\r\n\r\nHosting IronPigeon\r\n------------------\r\n\r\n### Composition\r\n\r\nThere are a small collection of objects that work together to provide the\r\nfunctions required to send and receive messages.  These objects can be\r\nmanually and individually instantiated, and properties set on them to point\r\nto the other objects you've created.  Or you can rely on MEF to do this work\r\nfor you.\r\n\r\nWhen targeting .NET 4.0, use MEF as it is found in the framework under the\r\n`System.ComponentModel.Composition` namespace.  \r\nWhen targeting .NET 4.5 or Windows 8, you should use the MEF \"v2\" found in the\r\n[Microsoft.Composition][3] NuGet package.  The code below assumes you're using\r\nthe MEF framework from NuGet.  Most fundamental IronPigeon services are in the\r\ncore IronPigeon assembly, so we add that entire assembly to the MEF catalog:\r\n\r\n\tvar configuration = new ContainerConfiguration()\r\n\t\t.WithAssembly(typeof(Channel).Assembly);\r\n\r\n\t// When targeting desktop apps:\r\n\tconfiguration.WithPart(typeof(DesktopCryptoProvider));\r\n\t// When targeting WinRT apps:\r\n\tconfiguration.WithAssembly(typeof(WinRTChannel).Assembly);\r\n\r\nAccording to standard MEF code, you'll need a container to begin using\r\ninstances of these services:\r\n\r\n\tvar container = configuration.CreateContainer();\r\n\r\nYou will need to configure some of these services (setting properties, etc.)\r\nand other services you'll call methods on to actually send and receive\r\nmessages.  You can acquire these services directly from the container using:\r\n\r\n\tvar someService = container.GetExport<T>();\r\n\r\nThe preferred approach however is that you define your own MEF part with\r\nimporting properties that will automatically be set to instances of these\r\nservices, like this:\r\n\r\n\t[Export]\r\n\tpublic class MyImports {\r\n\t\t[Import]\r\n\t\tpublic /*WinRT*/Channel Channel { get; set; }\r\n\r\n\t\t[Import]\r\n\t\tpublic RelayCloudBlobStorageProvider MessageRelayService { get; set; }\r\n\r\n\t\t[Import]\r\n\t\tpublic ICryptoProvider CryptoProvider { get; set; }\r\n\r\n\t\t[Import]\r\n\t\tpublic OwnEndpointServices OwnEndpointServices { get; set; }\r\n\t}\r\n\r\nThe latter approach will require that you add your part to the MEF catalog\r\nprior to creating the container:\r\n\r\n\tconfiguration.WithPart(typeof(MyImports));\r\n\r\n### Configuration\r\n\r\nIronPigeon has three settings that it needs to work:\r\n\r\n1. A URL to post public blobs to\r\n2. A URL to request new inboxes from\r\n3. The length of asymmetric keys to generate for newly created endpoints.\r\n\r\nAssuming the context of running inside the `MyImports` class as defined above,\r\nthe following code demonstrates configuring the above listed settings.\r\n\r\n\tthis.MessageRelayService.BlobPostUrl = new Uri(\"https://ironpigeon.azurewebsites.net/api/blob/\");\r\n\tthis.MessageRelayService.InboxServiceUrl = new Uri(\"https://ironpigeon.azurewebsites.net/Inbox/\");\r\n\tthis.CryptoProvider.ApplySecurityLevel(SecurityLevel.Minimum); // minimum is good for testing as keys generate faster\r\n\r\nThe URLs above are examples.  They can point to any compatible cloud service.\r\n\r\nEstablishing a communications channel\r\n-------------------------------------\r\n\r\nTo send a message via IronPigeon, a pair of endpoints must exist.\r\nEndpoints have both public and private components, containing the public\r\nand private cryptographic key pairs respectively.  When party *A* shares its\r\npublic endpoint with party *B*, party *B* can send party *A* messages.\r\nWhen two parties each create their own endpoints and exchange their public\r\ncomponents, the two parties may communicate securely.\r\n\r\n### Creating an endpoint\r\nThe following code creates a new endpoint.\r\n\r\n\tthis.Channel.Endpoint = await this.OwnEndpointServices.CreateAsync();\r\n\r\nAn `OwnEndpoint` instance includes the private keys required for receiving\r\nmessages at that endpoint.  It is therefore usually advisable to persist the\r\nprivate keys after creating the endpoint so that messages can be received\r\nin a subsequent session of the application.\r\n\r\n\tusing (var stream = File.OpenWrite(\"user private endpoint file\")) {\r\n\t\tawait this.Channel.Endpoint.SaveAsync(stream);\r\n\t}\r\n\r\n### Publishing an endpoint so others may send messages to it\r\n\r\nThe `OwnEndpoint.PublicEndpoint` property contains the public data that a\r\nremote party needs to send messages to your endpoint.  The public endpoint\r\nmay be transmitted to interested remote parties by any means.  One method is\r\nto publish the public endpoint data to a web server and share the URL to that\r\ndata with the remote party.  Publishing the endpoint and obtaining the URL can\r\nbe done with a single line:\r\n\r\n\tUri shareableAddress = await this.OwnEndpointServices.PublishAddressBookEntryAsync(this.Channel.Endpoint);\r\n\r\nA remote party can turn this URL back into a public `Endpoint` like this:\r\n\r\n\t[Import]\r\n\tpublic DirectEntryAddressBook AddressBook { get; set; }\r\n\r\n\tEndpoint friend = await this.AddressBook.LookupAsync(shareableAddress);\r\n\r\nSending and receiving messages\r\n------------------------------\r\n\r\n### Sending a message\r\n\r\nA simple text message can be sent to a remote party:\r\n\r\n\tvar payload = new Payload(Encoding.UTF8.GetBytes(\"hello, world\"), \"text/plain\");\r\n\tvar recipients = new[] { friend };\r\n\tvar expiration = DateTime.UtcNow + TimeSpan.FromMinutes(5);\r\n\tawait this.Channel.PostAsync(payload, recipients, expiration);\r\n\r\n### Receiving messages\r\n\r\nChecking the cloud inbox for inbound messages to your endpoint can be done in\r\nany of a few ways.  \r\n\r\nThis line will check for any incoming messages and immediately return with\r\nthe set of messages that were waiting.  If no messages were waiting, an empty\r\nset is returned:\r\n\r\n\tvar incoming = await this.Channel.ReceiveAsync();\r\n\r\nTo receive long-poll style push notification of any incoming messages, add a\r\n`longPoll: true` parameter.  This will cause the receive operation to complete\r\nonly when a message is actually received.  In this way, you can use an\r\nasynchronous loop to continuously receive and process messages as soon as they\r\narrive.\r\n\r\n\tvar incoming = await this.Channel.ReceiveAsync(longPoll: true);\r\n\r\nEither way, processing the incoming messages is simple:\r\n\r\n\tforeach (var payload in incoming) {\r\n\t\tvar message = Encoding.UTF8.GetString(payload.Content);\r\n\t\tConsole.WriteLine(message);\r\n\t}\r\n\r\nFinally, if you're building a Windows 8 app, you can employ the \r\nWindows Push Notification service and avoid using a long poll connection\r\nyourself, allowing your application to receiving notifications even when it is\r\nnot running, or when the computer is in a low power state:\r\n\r\n\t[Import]\r\n\tpublic WinRTChannel Channel { get; set; }\r\n\r\n\tawait this.Channel.RegisterPushNotificationChannelAsync(...);\r\n\r\nEmail-like communications\r\n-------------------------\r\n\r\nIf the messages to exchange resemble emails, consider using Dart as the\r\nmessage format.  This is facilitated by the `PostalService` and `Message`\r\ntypes:\r\n\r\n\tconfiguration.WithAssembly(typeof(PostalService).Assembly);\r\n\r\n\t[Import]\r\n\tpublic PostalService PostalService { get; set; }\r\n\r\n\tvar message = new Message(ownEndpoint, recipients, \"subject\", \"body\");\r\n\tawait this.PostalService.PostAsync(message);\r\n\tvar incoming = await this.PostalService.ReceiveAsync(longPoll: true|false);\r\n\r\n[1]: http://nuget.org/packages/IronPigeon            \"IronPigeon NuGet package\"\r\n[2]: http://nuget.org/packages/IronPigeon.Dart       \"IronPigeon.Dart NuGet package\"\r\n[3]: http://nuget.org/packages/Microsoft.Composition \"Microsoft.Composition NuGet package\"\r\n","google":"UA-69958-14","name":"Ironpigeon","tagline":"IronPigeon is a decentralized communication protocol that provides high confidentiality and authenticity for the messages.","note":"Don't delete this file! It's used internally to help with page regeneration."}